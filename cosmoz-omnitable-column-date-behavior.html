<script>
	window.Cosmoz = window.Cosmoz || {};

	/** @polymerBehavior */
	Cosmoz.DateColumnBehavior = {
		properties: {
			/**
			 * Ask for a list of values
			 */
			bindValues: {
				type: Boolean,
				readOnly: true,
				value: true
			},

			filter: {
				type: Object,
				computed: '_computeFilter(_filterInput.start, _filterInput.end)'
			},

			max: {
				type: Date,
				value() {
					return new Date('2100-01-01');
				}
			},

			min: {
				type: Date,
				value() {
					return new Date('1970-01-01');
				}
			},

			values: {
				type: Array,
				value() {
					return [];
				}
			},

			_filterInput: {
				type: Object,
				value() {
					return {
						start: null,
						end: null
					};
				}
			},

			_filterText: {
				type: String,
				computed: '_computeFilterText(locale, filter.*)'
			},

			_possibleDateRange: {
				type: Object,
				computed: '_computePossibleDateRange(values.*)'
			},

			_fromMax: {
				type: Object,
				computed: '_getMinMax(_toMax, _filterInput.end, 0)'
			},

			_fromMin: {
				type: Object,
				computed: '_getMinMax(_possibleDateRange.min, min, 0)'
			},

			_toMax: {
				type: Object,
				computed: '_getMinMax(_possibleDateRange.max, max, 1)'
			},

			_toMin: {
				type: Object,
				computed: '_getMinMax(_fromMin, _filterInput.start, 1)'
			},

			_earliestBefore: {
				type: Object,
				computed: '_getMinMax(_possibleDateRange.min, _filterInput.start, 1)'
			},

			_tooltip: {
				type: String,
				computed: '_computeTooltip(title, _filterText)'
			},

			width: {
				type: String,
				value: '100px'
			},

			editWidth: {
				type: String,
				value: '150px'
			},

			/**
			 * No need to grow, as the values in a date column should have known fixed width
			 * @returns {String} Default flex
			 */
			flex: {
				type: String,
				value: '0'
			},
			formatter: {
				type: Object,
				computed: '_computeFormatter(locale)'
			},
			locale: {
				type: String,
				value: null
			}
		},

		_computeFormatter(locale) {
			return new Intl.DateTimeFormat(locale || undefined);
		},

		_getMinMax(firstRaw, secondRaw, max) {
			var doMax = max === 1,
				first = this.getDate(firstRaw),
				second = this.getDate(secondRaw);
			if (!first && !second) {
				return null;
			}

			if ((!first || first === 'Invalid Date') && second) {
				return second;
			}

			if ((!second || second === 'Invalid Date') && first) {
				return first;
			}

			if (first.getTime() < second.getTime()) {
				return doMax ? second : first;
			}

			return doMax ? first : second;
		},

		_computePossibleDateRange(change) {
			var values = change.base,
				test;
			if (!values || !Array.isArray(values) || values.length < 1) {
				return {
					min: null,
					max: null
				};
			}
			if (!this.formatter) {
				return {
					min: null,
					max: null
				};
			}
			return values.reduce(function (acc, item) {
				var currRange = new Date(item);
				if (!acc.min || currRange < acc.min) {
					acc.min = currRange;
				}
				if (!acc.max || currRange > acc.max) {
					acc.max = currRange;
				}
				return acc;
			}, {});
		},

		_computeTooltip(title, filterText) {
			var ret = title;
			if (filterText !== undefined && filterText !== null) {
				ret += ': ' + filterText;
			}
			return ret;
		},

		_formatISODate(filterValue) {
			return new Date(filterValue);
		},

		_computeFilter(start, end) {
			return {
				start: start ? this.getDate(start) : null,
				end: end ? this.getDate(end) : null,
			};
		},

		_computeFilterText(locale, filterNotify, formatter = this.formatter) {
			var filter = filterNotify.base,
				text = [],
				tempValue;
			if (formatter && filter.start && filter.start !== null) {
				tempValue = this.getDate(filter.start);
				text.push(formatter.format(tempValue));
			}
			text.push(' - ');
			if (formatter && filter.end && filter.end !== null) {
				tempValue = this.getDate(filter.end);
				text.push(formatter.format(tempValue));
			}
			return text.length > 1 ? text.join('') : null;
		},

		_dateValueChanged(event) {
			var
				input = event.currentTarget,
				value = input.value,
				item = event.model.item,
				oldValue = this.get(this.valuePath, item),
				formatFn = (value) => {
					return this.formatter.format(value);
				},
				dateValue;
			try {
				dateValue = new Date(value);
				this.set(this.valuePath, dateValue, item);
			} catch (err) {
				input.errorMessage = 'Invalid date';
			}
			this._fireItemChangeEvent(item, this.valuePath, oldValue, formatFn.bind(this));
		},

		getComparableValue(item, valuePath) {
			var value = this.get(valuePath, item),
				numericValue = new Date(value);
			return numericValue.getTime();
		},

		renderISODateValue(item, valuePath) {
			var value = this.get(valuePath, item);
			if (!value) {
				return;
			}
			return value.toISOString().slice(0, 10);
		},

		getString(item, valuePath, formatter = this.formatter) {
			var value = this.get(valuePath || this.valuePath, item);
			if (!value || !formatter) {
				return '';
			}
			if (!(value instanceof Date)) {
				value = new Date(value);
			}
			if (isNaN(value)) {
				return 'Invalid Date';
			}
			return formatter.format(value);
		},

		getDate(value) {
			var dateValue;
			if (!value) {
				return '';
			}
			if (!(value instanceof Date)) {
				dateValue = new Date(value);
			} else {
				return value;
			}
			if (isNaN(dateValue)) {
				return 'Invalid Date';
			}
			return dateValue;
		},

		getFilterFn() {
			if (!this.filter) {
				return;
			}
			return this._applySingleFilter.bind(this, this.filter);
		},

		_applySingleFilter(filter, item) {
			var value = this.get(this.valuePath, item),
				dateToCheck = this.getDate(value);

			if (filter.start && dateToCheck < filter.start) {
				return false;
			}

			if (filter.end && dateToCheck > filter.end) {
				return false;
			}
			return true;
		}
	};
</script>
