<script>
	window.Cosmoz = window.Cosmoz || {};

	/** @polymerBehavior */
	Cosmoz.DateColumnBehavior = {
		properties: {
			/**
			* This is the format used to interact with the user, i.e. the format used
			* to render dates and to parse date entered by the user.
			* Should be a moment.js date format (http://momentjs.com/docs/#/displaying/format/)
			*/
			userFormat: {
				type: String,
				value: 'L'
			},
			/**
			 * Ask for a list of values
			 */
			bindValues: {
				type: Boolean,
				readOnly: true,
				value: true
			},

			filter: {
				type: Object,
				computed: '_computeFilter(_filterInput.start, _filterInput.end)'
			},

			max: {
				type: Date,
				value() {
					return new Date('2100-01-01');
				}
			},

			min: {
				type: Date,
				value() {
					return new Date('1970-01-01');
				}
			},

			values: {
				type: Array,
				value() {
					return [];
				}
			},

			_filterInput: {
				type: Object,
				value() {
					return {
						start: null,
						end: null
					};
				}
			},

			_filterText: {
				type: String,
				computed: '_computeFilterText(locale, filter.*)'
			},

			_possibleDateRange: {
				type: Object,
				computed: '_computePossibleDateRange(values.*)'
			},

			_fromMax: {
				type: Object,
				computed: '_getMinMax(_toMax, _filterInput.end, 0)'
			},

			_fromMin: {
				type: Object,
				computed: '_getMinMax(_possibleDateRange.min, min, 0)'
			},

			_toMax: {
				type: Object,
				computed: '_getMinMax(_possibleDateRange.max, max, 1)'
			},

			_toMin: {
				type: Object,
				computed: '_getMinMax(_fromMin, _filterInput.start, 1)'
			},

			_earliestBefore: {
				type: Object,
				computed: '_getMinMax(_possibleDateRange.min, _filterInput.start, 1)'
			},

			_tooltip: {
				type: String,
				computed: '_computeTooltip(title, _filterText)'
			},

			width: {
				type: String,
				value: '100px'
			},

			editWidth: {
				type: String,
				value: '150px'
			},

			/**
			 * No need to grow, as the values in a date column should have known fixed width
			 * @returns {String} Default flex
			 */
			flex: {
				type: String,
				value: '0'
			},
			formatter: {
				type: Object,
				computed: '_computeFormatter(locale)'
			},
			locale: {
				type: String,
				value: null
			}
		},

		_computeFormatter(locale) {
			return new Intl.DateTimeFormat(locale || undefined);
		},

		_getMinMax(firstRaw, secondRaw, max) {
			const doMax = max === 1,
				first = this.getDate(firstRaw),
				second = this.getDate(secondRaw);
			if (!first && !second) {
				return null;
			}

			if (!this._isValidDate(first) && second) {
				return second;
			}

			if (!this._isValidDate(second) && first) {
				return first;
			}

			if (first.getTime() < second.getTime()) {
				return doMax ? second : first;
			}

			return doMax ? first : second;
		},

		_computePossibleDateRange(change) {
			let values = change.base;
			if (!values || !Array.isArray(values) || values.length < 1) {
				return {
					min: null,
					max: null
				};
			}
			return values.reduce((acc, item) => {
				const currRange = this.getDate(item);
				if (!this._isValidDate(currRange)) {
					return acc;
				}
				if (!acc.min || currRange < acc.min) {
					acc.min = currRange;
				}
				if (!acc.max || currRange > acc.max) {
					acc.max = currRange;
				}
				return acc;
			}, {});
		},

		_computeTooltip(title, filterText) {
			let ret = title;
			if (filterText !== undefined && filterText !== null) {
				ret += ': ' + filterText;
			}
			return ret;
		},
	
		_formatISODate(filterValue) {
			if (!this._isValidDate(filterValue)) {
				return '';
			}
			return filterValue.toISOString().slice(0, 10);
		},

		_computeFilter(start, end) {
			return {
				start: start ? this.getDate(start) : null,
				end: end ? this.getDate(end) : null,
			};
		},

		_computeFilterText(locale, filterNotify, formatter = this.formatter) {
			let text = [];
			const startDate = filterNotify.base.start,
				endDate = filterNotify.base.end;
			if (!formatter) {
				return null;
			}
			if (startDate && startDate !== null) {
				text.push(formatter.format(this.getDate(startDate)));
			}
			text.push(' - ');
			if (endDate && endDate !== null) {
				text.push(formatter.format(this.getDate(endDate)));
			}
			return text.length > 0 ? text.join('') : null;
		},

		_dateValueChanged(event) {
			const
				input = event.currentTarget,
				value = input.value,
				item = event.model.item,
				oldValue = this.get(this.valuePath, item),
				formatFn = (value) => {
					return this.formatter.format(value);
				};
			try {
				let dateValue = new Date(value);
				this.set(this.valuePath, dateValue, item);
			} catch (err) {
				input.errorMessage = 'Invalid date';
			}
			this._fireItemChangeEvent(item, this.valuePath, oldValue, formatFn.bind(this));
		},

		getComparableValue(item, valuePath) {
			const numericValue = this.getDate(this.get(valuePath, item));
			if (!this._isValidDate(numericValue)) {
				return null;
			}
			return numericValue.getTime();
		},

		renderISODateValue(item, valuePath) {
			const value = this.get(valuePath, item);
			if (!value) {
				return;
			}
			return value.toISOString().slice(0, 10);
		},

		getString(item, valuePath, formatter = this.formatter) {
			const value = this.getDate(this.get(valuePath || this.valuePath, item));
			if (!this._isValidDate(value)) {
				return 'Invalid Date';
			}
			return formatter.format(value);
		},
	
		getDate(value) {
			let dateValue = value;
			if (!dateValue) {
				return '';
			}
			if (!(dateValue instanceof Date)) {
				dateValue = new Date(dateValue);
			} else {
				return dateValue;
			}
			if (isNaN(dateValue)) {
				return 'Invalid Date';
			}
			return dateValue;
		},

		getFilterFn() {
			if (!this.filter) {
				return;
			}
			return this._applySingleFilter.bind(this, this.filter);
		},

		_applySingleFilter(filter, item) {
			const dateToCheck = this.getDate(this.get(this.valuePath, item));

			if (filter.start && dateToCheck < filter.start) {
				return false;
			}

			if (filter.end && dateToCheck > filter.end) {
				return false;
			}
			return true;
		},
	
		_isValidDate(value) {
			if (!value || !value === null || value === 'Invalid Date') {
				return false;
			}
			return true;
		}
	};
</script>
