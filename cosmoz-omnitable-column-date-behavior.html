<link rel="import" href="cosmoz-omnitable-column-range-behavior.html">
<script>
	window.Cosmoz = window.Cosmoz || {};

	/** @polymerBehavior */
	Cosmoz.DateColumnBehaviorImpl = {
		properties: {
			max: {
				type: Date,
				value() {
					return new Date('2100-01-01');
				}
			},

			min: {
				type: Date,
				value() {
					return new Date('1970-01-01');
				}
			},

			_filterText: {
				type: String,
				computed: '_computeFilterText(filter.*, formatter)'
			},

			width: {
				type: String,
				value: '100px'
			},

			editWidth: {
				type: String,
				value: '150px'
			},

			/**
			 * No need to grow, as the values in a date column should have known fixed width
			 * @returns {String} Default flex
			 */
			flex: {
				type: String,
				value: '0'
			},
			formatter: {
				type: Object,
				computed: '_computeFormatter(locale)'
			}
		},

		toDate(value, limit, limitFunc) {
			if (value == null || value === '') {
				return;
			}
			const date = value instanceof Date ? value : new Date(value);
			if (Number.isNaN(date.getTime())) {
				return null;
			}
			if (limitFunc == null || limit == null) {
				return date;
			}
			let lDate = this.toDate(limit);
			if (lDate == null) {
				return date;
			}
			return limitFunc(date, lDate);
		},

		toValue() {
			return this.toDate.apply(this, arguments);
		},

		getComparableValue() {
			const value = Cosmoz.RangeColumnBehavior.getComparableValue.apply(this, arguments);
			if (value == null) {
				return;
			}
			return this.toNumber(value.getTime());
		},

		getString(item, valuePath = this.valuePath, formatter = this.formatter) {
			const value = this.toValue(this.get(valuePath, item));
			if (value === undefined) {
				return '';
			}
			if (value === null) {
				return 'Invalid Date';
			}
			return this.renderValue(value, formatter);
		},

		renderValue(value, formatter = this.formatter) {
			const date = this.toValue(value);
			if (date == null) {
				return;
			}
			return formatter.format(date);
		},

		_computeFormatter(locale) {
			return new Intl.DateTimeFormat(locale || undefined);
		},

		_toInputString(value) {
			const date = this.toValue(value);
			if (date == null) {
				return;
			}
			return this._toLocalISOString(date).slice(0, 10);
		},

		_formatISODate(filterValue) {
			if (!this._isValidDate(filterValue)) {
				return '';
			}
			return filterValue.toISOString().slice(0, 10);
		},

		_dateValueChanged(event) {
			const
				input = event.currentTarget,
				value = input.value,
				item = event.model.item,
				oldValue = this.get(this.valuePath, item),
				formatFn = value => this.formatter.format(value),
				dateValue = this.getDate(value);
			if (!this._isValidDate(dateValue)) {
				return;
			}
			this.set(this.valuePath, dateValue, item);
			this._fireItemChangeEvent(item, this.valuePath, oldValue, formatFn.bind(this));
		},

		renderISODateValue(item, valuePath) {
			const value = this.getDate(this.get(valuePath, item));
			if (!this._isValidDate(value)) {
				return;
			}
			return value.toISOString().slice(0, 10);
		},

		getDate(value) {
			if (!value) {
				return null;
			}
			if (!(value instanceof Date)) {
				return new Date(value);
			}
			return value;
		},


		// _applySingleFilter(filter, item) {
		// 	const dateToCheck = this.getDate(this.get(this.valuePath, item));
		// 	if (filter.start && (!this._isValidDate(dateToCheck) || dateToCheck < filter.start)) {
		// 		return false;
		// 	}
		// 	if (filter.end && (!this._isValidDate(dateToCheck) || dateToCheck > filter.end)) {
		// 		return false;
		// 	}
		// 	return true;
		// },

		_isValidDate(value) {
			if (!value) {
				return false;
			}
			let dateValue = value;
			if (!(dateValue instanceof Date)) {
				dateValue = new Date(dateValue);
			}
			if (isNaN(dateValue)) {
				return false;
			}
			return true;
		},

		_toLocalISOString: function (date) {
			if (!(date instanceof Date)) {
				return null;
			}
			const pad = number => number < 10 ? '0' + number : number;
			return date.getFullYear() +
				'-' + pad(date.getMonth() + 1) +
				'-' + pad(date.getDate()) +
				'T' + pad(date.getHours()) +
				':' + pad(date.getMinutes()) +
				':' + pad(date.getSeconds()) +
				'.' + (date.getMilliseconds() / 1000).toFixed(3).slice(2, 5);
		}
	};
	Cosmoz.DateColumnBehavior = [Cosmoz.RangeColumnBehavior, Cosmoz.DateColumnBehaviorImpl];
</script>
