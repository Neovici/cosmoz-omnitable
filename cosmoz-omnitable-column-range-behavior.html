<script>
	window.Cosmoz = window.Cosmoz || {};

	/** @polymerBehavior */
	Cosmoz.RangeColumnBehavior = {
		properties: {
			bindValues: {
				type: Boolean,
				readOnly: true,
				value: true
			},

			values: {
				type: Array,
				value: function () {
					return [];
				}
			},

			min: {
				type: Number,
				value: null
			},

			max: {
				type: Number,
				value: null
			},

			_filterInput: {
				type: Object,
				value() {
					return { min: null, max: null };
				}
			},

			_range: {
				type: Object,
				computed: '_computeRange(values.*)'
			},

			_limit: {
				type: Object,
				computed: '_computeLimit(_range, _filterInput.*, min, max)'
			},

			_tooltip: {
				type: String,
				computed: '_computeTooltip(title, _filterText)'
			},
		},

		observers: [
			'_filterInputChanged(_filterInput.*)',
			'_filterChanged(filter.*)'
		],

		toNumber(value) {
			if (value == null || value === '') {
				return;
			}
			if (typeof value === 'number') {
				return value;
			}
			const number = Number(value);
			if (Number.isNaN(number)) {
				return;
			}
			return number;
		},

		toLimitedNumber(value, limit, limitFunc) {
			const number = this.toNumber(value);
			if (number == null) {
				return;
			}
			if (limit == null || limitFunc == null) {
				return number;
			}
			return limitFunc(number, limit);
		},

		getComparableValue(item, valuePath) {
			let value = item;
			if (valuePath != null) {
				value = this.get(valuePath, item);
			}
			return this.toNumber(value);
		},

		_computeRange(change) {
			const values = change.base,
				numbers = Array.isArray(values) && values.length && values.map(i => this.getComparableValue(i)).filter(n => n != null);

			if (!numbers || numbers.length < 1) {
				return {
					min: null,
					max: null
				};
			}
			return {
				min: Math.min.apply(null, numbers),
				max: Math.max.apply(null, numbers)
			};
		},

		_computeLimit(range, inputChange, min, max) {
			const input = inputChange.base,
				nMin = this.toNumber(min),
				nMax = this.toNumber(max);
			return {
				fromMin: nMin != null ? this.toNumber(min) : this.toNumber(range.min),
				fromMax: this.toLimitedNumber(range.max, this.toLimitedNumber(input.max), Math.min),
				toMin: this.toLimitedNumber(range.min, this.toNumber(input.min), Math.max),
				toMax: nMax != null ? this.toNumber(max) : this.toNumber(range.min)
			};
		},

		getFilterFn() {
			const min = this.getComparableValue(this.filter, 'min'),
				max = this.getComparableValue(this.filter, 'max');

			if (min == null && max == null) {
				return;
			}
			return this._applySingleFilter.bind(this, this.filter);
		},

		_applySingleFilter: function (filter, item) {
			var value = this.getComparableValue(item, this.valuePath),
				minValue = this.getComparableValue(filter, 'min'),
				maxValue = this.getComparableValue(filter, 'max');

			if (value < minValue) {
				return false;
			}

			if (value > maxValue) {
				return false;
			}

			return true;
		},

		_computeTooltip(title, text) {
			if (text == null) {
				return title;
			}
			return `${title}: ${text}`;
		},


		_filterInputChanged() {
			this.debounce('_updateFilter', this._updateFilter, 600);
		},

		_updateFilter() {
			const input = this._filterInput,
				filter = this.filter,
				limit = this._limit,
				min = this.toNumber(input.min),
				max = this.toNumber(input.max),
				lMin = this.toLimitedNumber(input.min, this.toNumber(limit.fromMax), Math.min),
				lMax = this.toLimitedNumber(input.max, this.toNumber(limit.toMin), Math.max);

			if (lMin !== min || lMax !== max) {
				this.set('_filterInput', { min: lMin, max: lMax });
				this.flushDebouncer('_updateFilter');
				return;
			}

			if (min === this.getComparableValue(filter, 'min') && max === this.getComparableValue(filter, 'max')) {
				return;
			}

			this._updateFilterFromInput(min, max);

		},

		_updateFilterFromInput(min, max) {
			this.set('filter', { min, max });
		},

		_filterChanged(change) {
			const input = this._filterInput,
				filter = change.base,
				min = this.getComparableValue(filter, 'min'),
				max = this.getComparableValue(filter, 'max');

			if (!input || min === this.toNumber(input.min) && max === this.toNumber(input.max)) {
				return;
			}
			this.set('_filterInput', { min, max });
			this.cancelDebouncer('_updateFilter');
		},

		_serializeFilter(filter = this.filter) {
			const min = this.getComparableValue(filter, 'min'),
				max = this.getComparableValue(filter, 'max');

			if (min == null && max == null) {
				return this.serialize(null);
			}
			return (min == null ? '' : min) + '~' + (max == null ? '' : max);
		},

		_deserializeFilter(obj) {
			if (obj == null || obj  === '') {
				return null;
			}
			const matches = obj.match(/^([-0-9.]+)?~([-0-9.]+)?/i);

			if (!Array.isArray(matches)) {
				return null;
			}

			return {
				min: this.toNumber(matches[1]),
				max: this.toNumber(matches[2])
			};
		},
	};
</script>
